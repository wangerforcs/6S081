proc.c文件好好看好好学，对于理解操作系统的进程管理有很大帮助。

两个线程对共享数据进行写操作，不加锁导致数据不一致。可能是由于同时把一个kay-value添加到同一个列表的头，并修改table项，导致实际上一个线程没存进去。
put中读的时候不加锁，可能会导致不同线程负责的相同的key，被添加到同一个链表里，简单修改ph.c，将keys设置为某个常数，输出哈希表就能发现。
对于如下代码
```C++
void printtable()
{
  for(int i=0;i<NBUCKET;i++)
  {
    struct entry *e = 0;
    for (e = table[i]; e != 0; e = e->next) {
        printf("%d %d--",e->key,e->value);
    }
    printf("\n");
  }
}
```
整体加锁的输出为3 0--或者3 1--，不会出现多个entry，而只对写加锁时，测试几次就能发现3 1--3 0--
某种程度上不符合，但本题未要求，只是需要所有key都能够get，而不管key重复。
而且如果读的时候也加锁，会导致实际上运行的比较慢，通不过测试.

单看三个测试来说，这次实验不算难，但仔细看书和源代码其实挺折磨。